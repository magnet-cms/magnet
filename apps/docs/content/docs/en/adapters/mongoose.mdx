---
title: Mongoose Adapter
description: MongoDB database adapter using Mongoose ODM
---

# Mongoose Adapter

The Mongoose adapter provides MongoDB support using the Mongoose ODM.

## Installation

```bash
bun add @magnet/adapter-mongoose
```

## Configuration

```ts
import { MagnetModule } from '@magnet/core'
import { MongooseAdapter } from '@magnet/adapter-mongoose'

MagnetModule.forRoot({
  adapter: new MongooseAdapter({
    uri: 'mongodb://localhost:27017/magnet',
    options: {
      maxPoolSize: 10,
      serverSelectionTimeoutMS: 5000,
    },
  }),
})
```

### Options

| Option | Type | Description |
|--------|------|-------------|
| `uri` | string | MongoDB connection URI |
| `options` | object | Mongoose connection options |

## Connection Options

```ts
new MongooseAdapter({
  uri: process.env.MONGODB_URI,
  options: {
    maxPoolSize: 10,
    minPoolSize: 2,
    serverSelectionTimeoutMS: 5000,
    socketTimeoutMS: 45000,
    family: 4, // Use IPv4
  },
})
```

## Features

### Schema Registration

Schemas decorated with `@Schema` are automatically registered:

```ts
@Schema({ collection: 'posts' })
export class Post {
  @Prop({ required: true })
  title: string
}
```

### Mongoose-Specific Features

Access Mongoose models directly:

```ts
import { Injectable } from '@nestjs/common'
import { InjectModel } from '@nestjs/mongoose'
import { Model } from 'mongoose'

@Injectable()
export class PostsService {
  constructor(@InjectModel('Post') private postModel: Model<Post>) {}

  async findWithAggregate() {
    return this.postModel.aggregate([
      { $match: { published: true } },
      { $group: { _id: '$category', count: { $sum: 1 } } },
    ])
  }
}
```

### Internationalization

The adapter supports i18n for multilingual content:

```ts
@Schema({ collection: 'posts' })
export class Post {
  @Prop()
  @UI({ i18n: true })
  title: string // Will store as { en: '...', pt: '...' }
}
```

## Query Builder

The Mongoose adapter provides a powerful query builder for advanced database operations with sorting, pagination, filtering, and projection support.

### Basic Usage

```ts
import { InjectModel, Model } from '@magnet/common'

@Injectable()
export class PostsService {
  constructor(@InjectModel(Post) private postModel: Model<Post>) {}

  async findRecentPosts() {
    return this.postModel
      .query()
      .where({ status: 'published' })
      .sort({ createdAt: -1 })
      .limit(10)
      .exec()
  }
}
```

### Query Operators

The query builder supports MongoDB operators for advanced filtering:

```ts
// Greater than / Less than
const recentPosts = await postModel
  .query()
  .where({ createdAt: { $gte: lastWeek } })
  .exec()

// In array
const featured = await postModel
  .query()
  .where({ category: { $in: ['tech', 'science'] } })
  .exec()

// Regex search
const matching = await postModel
  .query()
  .where({ title: { $regex: 'magnet', $options: 'i' } })
  .exec()

// Exists check
const withThumbnail = await postModel
  .query()
  .where({ thumbnail: { $exists: true } })
  .exec()
```

### Sorting

```ts
// Single field sort
const posts = await postModel
  .query()
  .sort({ createdAt: -1 }) // -1 for descending, 1 for ascending
  .exec()

// Multiple field sort
const posts = await postModel
  .query()
  .sort({ featured: -1, createdAt: -1 })
  .exec()
```

### Pagination

```ts
const page = 1
const pageSize = 20

const posts = await postModel
  .query()
  .where({ status: 'published' })
  .sort({ createdAt: -1 })
  .skip((page - 1) * pageSize)
  .limit(pageSize)
  .exec()

// Or use paginate() for total count
const result = await postModel
  .query()
  .where({ status: 'published' })
  .skip((page - 1) * pageSize)
  .limit(pageSize)
  .paginate()

// result = { data: [...], total: 150, limit: 20, page: 1 }
```

### Logical Operators

```ts
// AND conditions
const posts = await postModel
  .query()
  .where({ status: 'published' })
  .and({ featured: true })
  .exec()

// OR conditions
const posts = await postModel
  .query()
  .or([
    { status: 'published' },
    { status: 'draft', author: currentUserId },
  ])
  .exec()
```

### Count and Exists

```ts
// Count matching documents
const count = await postModel
  .query()
  .where({ status: 'published' })
  .count()

// Check if any matching documents exist
const hasPublished = await postModel
  .query()
  .where({ status: 'published' })
  .exists()
```

### Field Selection

```ts
// Select only specific fields
const posts = await postModel
  .query()
  .where({ status: 'published' })
  .select({ title: 1, slug: 1, createdAt: 1 })
  .exec()
```

### Locale Support

The query builder inherits locale context from the model:

```ts
const posts = await postModel
  .locale('pt-BR')
  .query()
  .where({ status: 'published' })
  .exec()
```

### Native Model Access

For advanced use cases, access the underlying Mongoose model:

```ts
// Get the native Mongoose model
const nativeModel = postModel.native()

// Use native Mongoose features
const result = await nativeModel.aggregate([
  { $match: { status: 'published' } },
  { $group: { _id: '$category', count: { $sum: 1 } } },
])
```

<Callout type="warning">
Using `native()` bypasses Magnet abstractions like locale handling and ID mapping. Use with caution.
</Callout>

## Environment Variables

```bash
# MongoDB connection
MONGODB_URI=mongodb://localhost:27017/magnet

# For replica sets
MONGODB_URI=mongodb://host1:27017,host2:27017,host3:27017/magnet?replicaSet=rs0
```

<Callout type="info">
For production, use MongoDB Atlas or a managed MongoDB service with proper authentication and SSL.
</Callout>
